/*/
 * Copyright (c) 2019 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *                                              Martin Jacquet - November 2019
 */

/* ---- Includes ---- */

#pragma require "openrobots2-idl >= 2.0"

#include "d435Struct.idl"

/* ---- Component declaration ---- */

component d435 {
    version	    "0.1";
    email		"martin.jacquet@laas.fr";
    lang		"c";
    require	    "genom3 >= 2.99.26";

    /* ---- Exceptions ---- */

    exception rs_error { string<128> what; };
    exception mem_error { string<128> what; };

    /* ---- IDS ---- */

    struct portinfo_s {
      string<128> name;
      or::time::ts last;
    };

    ids {
        d435::pipe_s        pipe;
        d435::RSdata_s      data;
        boolean             started;

        d435::frame_s       frame;
        d435::pc_s          pc;

        // sequence<portinfo_s>    ports;
    };

    /* ---- Ports ---- */

    port            out d435::pc_s     pc_out;
    // port multiple   out d435::frame_s  rgb_out;
    port            out d435::frame_s  rgb_out;
    port            out d435::seq5F    calib;
    port            out d435::seq5F    disto;


    /* ---- Tasks ---- */

    const unsigned short rgb_pub_period_ms = 10;
    const unsigned short depth_pub_period_ms = 100;

    task hw_comm {
        codel<start> d435_comm_start(out pipe, out started)
            yield poll;

        async codel<poll> d435_comm_poll(inout pipe)
            yield pause::poll, read;

        codel<read> d435_comm_read(in pipe, out data, out started)
            yield poll;

        codel<stop> d435_comm_stop()
            yield ether;
    };

    task rgb_publish {
        period rgb_pub_period_ms ms;

        codel<start> d435_rgb_start(in started)
            yield pause::start, pub;

        codel<pub> d435_rgb_pub(in data, inout frame, out rgb_out)
            yield pause::pub;

        codel<stop> d435_rgb_stop()
            yield ether;
    };

    task depth_publish {
        period depth_pub_period_ms ms;

        codel<start> d435_depth_start(in started)
            yield pause::start, pub;

        codel<pub> d435_depth_pub(in data, inout pc, out pc_out)
            yield pause::pub;

        codel<stop> d435_depth_stop()
            yield ether;
    };

    /* ---- Activities ---- */

    activity set_fps (
        in string<64> serial = "img_pub" : "Out port name",
        in unsigned short fps = 60 : "Publish frequency")
    {
        task rgb_publish;

        codel<start> d435_set_frequency(in fps)
            yield ether;
    };

    activity connect () {
        task hw_comm;

        codel<start> d435_connect_start(out ::ids, out calib, out disto, out rgb_out, out pc_out)
            yield ether;
    };

};
